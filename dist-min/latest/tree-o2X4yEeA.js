const e=new CSSStyleSheet;e.replaceSync(':host {\n    display: block;\n    overflow: auto;\n    height: 100%;\n}\n\n.cont-children {\n    padding-left: 20px;\n    position: relative;\n    overflow: hidden;\n    display: block;\n\n    &::before {\n        content: \'\';\n        width: 0;\n        height: 100%;\n        position: absolute;\n        border: 1px solid lightgrey;\n        top: 0;\n        left: 11px;\n    }\n\n    &:hover {\n        &::before {\n            transition: border-color 0.2s;\n            border-color: grey;\n        }\n    }\n}\n\n.node-content {\n    padding: 8px 10px;\n    display: inline-block;\n    width: 100%;\n    width: -moz-available;          /* WebKit-based browsers will ignore this. */\n    width: -webkit-fill-available;  /* Mozilla-based browsers will ignore this. */\n    width: fill-available;\n    color: black;\n    text-decoration: none;\n    border-radius: 5px;\n    text-wrap: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    \n    &:hover {\n        background-color: whitesmoke;\n    }\n}\n\n.node[selected] {\n    .node-content {\n        background-color: whitesmoke;\n    }\n}\n\ndiv[type="root"] {\n    font-weight: 500;\n    display: flex;\n    flex-direction: column;\n\n    & > .node-content {\n        text-transform: uppercase;\n        cursor: pointer;\n        \n        &::before {\n            transition: transform 0.1s;\n            font-family: "Font Awesome 5 Pro";\n            content: "\\f105";\n            color: grey;\n            padding-right: 5px;\n            display: inline-block;\n            transform: rotate(90deg) translate(3px, 3px);\n        }\n    }\n}\n\ndiv[type="leaf"] {\n    font-weight: 400;\n    display: flex;\n    flex-direction: column;\n}\n\ndiv[closed] {\n    & > .cont-children {\n        display: none;\n    }\n\n    & > .node-content::before {\n        transition: transform 0.1s;\n        transform: rotate(0deg) translate(0, 0);\n    }\n}\n');class t extends HTMLElement{static observedAttributes=[];$contNodes;constructor(){super();let t=this.attachShadow({mode:"open"});this.$contNodes=document.createElement("div"),this.$contNodes.id="cont-nodes",t.append(this.$contNodes),t.adoptedStyleSheets=[e]}attributeChangedCallback(e,t,n){}addNode(e,t,n=!1){this._isSlotted(e)&&this.append(e);let o=this._nodeToLeaf(e,!0);n&&(o=this._nodeToRoot(o)),Array.isArray(t)||(t=[t]);for(const e of t)null==e&&this._setParent(o.cloneNode(!0),null);this._queryIds(t).forEach((e=>this._setParent(o.cloneNode(!0),e)))}connectedCallback(){let e=[];for(let t of Array.from(this.children)){let n=this._nodeToLeaf(t,!0);this.$contNodes.append(n),e.push(n)}for(let t of e){const e=t.getAttribute("parent");if(null==e){this.$contNodes.append(t);continue}const n=this.$contNodes.querySelector(`[node-id="${e}"]`);if(null==n)throw new Error("No parent found with id: "+e);this._setParent(t,n)}}filter(e,t=!1){null!=e&&(e=e.toLowerCase());for(const n of this.$contNodes.children)this._filterRecursive(n,e,!1,t);return this}getOpen(){return Array.from(this.$contNodes.querySelectorAll("[type=root]:not([closed])")).map((e=>e.getAttribute("node-id")))}getClosed(){return Array.from(this.$contNodes.querySelectorAll("[type=root][closed]")).map((e=>e.getAttribute("node-id")))}moveNode(e,t,n){if("inside"===e)return this.setParent(t,n);if(null==this._queryIds(t)[0])throw new Error(`Node with ID ${t} not found!`);this.$contNodes.querySelectorAll(`[node-id="${parentId}"]`).forEach((e=>{elems.forEach((t=>{this._setParent(t,e)}))}))}removeNode(e){let t=this._queryIds(e);if(null==t[0])throw new Error(`Node with ID ${e} not found!`);let n=this._nodeToInner(t[0]);for(let e of t)e.remove();return n}setClosed(e=null){return this.setClosed(e,!0),this}setOpen(e=null){return this._setClosed(e,!1),this}setParent(e,t){let n=this._queryIds(e);return null==t?(n.forEach((e=>this.$contNodes.append(e))),this):(this._queryIds(t).forEach((e=>{n.forEach((t=>{this._setParent(t,e)}))})),this)}toRootNode(e){let t=this._queryIds(e);for(const e of t)this._nodeToRoot(e);return this}_filterRecursive(e,t,n,o,r){let i=null==t;const l="root"===e.getAttribute("type");let s=e.hasAttribute("filter-text")?e.getAttribute("filter-text"):e.children[0].innerHTML;s=s.toLowerCase();let d=!1;(!l||l&&o)&&(d=r?s===t:s.includes(t)),i||=d;let c=!1;if(l){let r=e.children[1];for(const e of r.children){let r=this._filterRecursive(e,t,i||n,o);c=c||r}}return c?(e.style.display="",e.removeAttribute("closed")):i?(e.style.display="",e.setAttribute("closed","")):n?e.style.display="":(e.style.display="none",e.setAttribute("closed","")),i||c}_clickRootCallback(e){this._toggleChildren(e)}_hideChildren(e){e.setAttribute("closed","true")}_nodeToLeaf(e,t=!1){if(!t)throw new Error("Not implemented");let n=document.createElement("div");const o=e.getAttribute("parent");null!=o&&n.setAttribute("parent",o),null!=e.getAttribute("selected")&&n.setAttribute("selected","");let r=e.getAttribute("filter-text");null!=r&&n.setAttribute("filter-text",r),null!=e.getAttribute("closed")&&n.setAttribute("closed",!0);let i=e.getAttribute("node-id")??e.id;n.setAttribute("node-id",i),n.classList.add("node"),e.classList.add("node-content"),n.setAttribute("type","leaf");if(this._isSlotted(e)){let t="slot"+Math.floor(18999998*Math.random()+1e6).toString(),o=document.createElement("slot");e.slot=t,o.name=t,n.append(o)}else n.append(e);return n}_showChildren(e){e.removeAttribute("closed")}_setClosed(e=null,t=!0){if(null!=e)for(let n of this._queryIds(e))t?n.setAttribute("closed",""):n.removeAttribute("closed");else for(let e of this.$contNodes.querySelectorAll("[type=root]"))t?e.setAttribute("closed",""):e.removeAttribute("closed")}_setParent(e,t){null!=t?(this._nodeToRoot(t),t.children[1].append(e)):this.$contNodes.append(e)}_toggleChildren(e){e.getAttribute("closed")?this._showChildren(e):this._hideChildren(e)}_nodeToRoot(e){if("root"===e.getAttribute("type"))return e;e.setAttribute("type","root");let t=document.createElement("div");return t.classList.add("cont-children"),e.append(t),"click"===this.getAttribute("fold")&&e.children[0].addEventListener("click",(()=>this._clickRootCallback.bind(this)(e))),e}_nodeToInner(e){return this._isSlotted(e)?e.children[0].assignedElements()[0]:e.children[0]}_isSlotted(e){return e.hasAttribute("slotted")||this.hasAttribute("slotted")}_queryIds(e){Array.isArray(e)||(e=[e]);let t=[];for(let n of e)this.$contNodes.querySelectorAll(`.node[node-id="${n}"]`).forEach((e=>t.push(e)));return t}}customElements.get("he-tree")||customElements.define("he-tree",t);export{t as HeliumTree};
